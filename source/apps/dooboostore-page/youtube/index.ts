import { chromium } from 'playwright';
import fs from 'fs';
import path from 'path';
import process from 'process';

// YouTube Video IDë¥¼ ì—¬ê¸°ì„œ ë³€ê²½í•˜ì„¸ìš”
const YOUTUBE_VIDEO_ID = 'guRkQDSfiKk';

// ë²ˆì—­ ë°©ì‹ ì„ íƒ: 'youtube' (YouTube ìë™ë²ˆì—­) ë˜ëŠ” 'papago' (Papago API ë²ˆì—­)
const TRANSLATION_METHOD: 'youtube' | 'papago' = 'youtube';

// YouTube URL ìƒì„±
const YOUTUBE_URL = `https://www.youtube.com/watch?v=${YOUTUBE_VIDEO_ID}`;

// ì¶œë ¥ ë””ë ‰í† ë¦¬ ì„¤ì •
const OUTPUT_DIR = path.join(process.cwd(), 'dist-youtube-subtitles');
const VTT_DIR = path.join(process.cwd(), '..', '..', '..', 'datas', 'english', 'vtt');
const SCRIPTS_DIR = path.join(process.cwd(), '..', '..', '..', 'datas', 'english', 'scripts');
const ITEMS_JSON_PATH = path.join(process.cwd(), '..', '..', '..', 'datas', 'english', 'items.json');
const DICTIONARY_DIR = path.join(process.cwd(), '..', '..', '..', 'datas', 'english', 'dictionary');
const AUTO_TRANSLATION_DIR = path.join(process.cwd(), '..', '..', '..', 'datas', 'english', 'auto-translation');

interface SubtitleData {
  language: string;
  content: string;
  isAutoGenerated: boolean;
  url: string;
  originalJson?: any; // ì›ë³¸ JSON ë°ì´í„° ì €ì¥
}

interface SubtitleEntry {
  t: string;  // time in seconds like "0s", "6s"
  e: string;  // english text
  k: string;  // korean text
}

interface VideoItem {
  name: string;
  type: string;
  img: string;
  link: string;
}

interface PapagoResponse {
  items: Array<{
    entry: string;
    subEntry?: string;
    matchType: string;
    hanjaEntry?: string;
    phoneticSigns: Array<{
      type: string;
      sign: string;
    }>;
    pos: Array<{
      type: string;
      meanings: Array<{
        meaning: string;
        examples: Array<{
          text: string;
          translatedText: string;
        }>;
        originalMeaning: string;
      }>;
    }>;
    source: string;
    url: string;
    mUrl: string;
    expDicTypeForm: string;
    locale: string;
    conjugationList?: Array<{
      type: string;
      value: string;
    }>;
    aliasConjugation?: string;
    aliasConjugationPos?: string;
    gdid: string;
    expEntrySuperscript?: string;
  }>;
  examples: Array<{
    source: string;
    matchType: string;
    translatedText: string;
    text: string;
  }>;
  isWordType: boolean;
}

function convertJson3ToVtt(jsonData: any): string {
  try {
    if (!jsonData.events || !Array.isArray(jsonData.events)) {
      return '';
    }

    let vttContent = 'WEBVTT\n\n';
    let cueCount = 0;
    
    for (const event of jsonData.events) {
      if (event.segs && Array.isArray(event.segs)) {
        const startTime = formatTime(event.tStartMs || 0);
        const duration = event.dDurationMs || 3000;
        const endTime = formatTime((event.tStartMs || 0) + duration);
        
        const text = event.segs.map((seg: any) => seg.utf8 || '').join('').trim();
        
        if (text) {
          vttContent += `${startTime} --> ${endTime}\n${text}\n\n`;
          cueCount++;
        }
      }
    }
    
    console.log(`âœ… Converted ${cueCount} subtitle cues to VTT format`);
    return vttContent;
  } catch (error) {
    console.log('âŒ Error converting JSON3 to VTT:', error);
    return '';
  }
}

function formatTime(milliseconds: number): string {
  const totalSeconds = Math.floor(milliseconds / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  const ms = milliseconds % 1000;
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
}

function parseVttTime(timeStr: string): number {
  const parts = timeStr.split(':');
  const hours = parseInt(parts[0]);
  const minutes = parseInt(parts[1]);
  const secondsParts = parts[2].split('.');
  const seconds = parseInt(secondsParts[0]);
  const milliseconds = parseInt(secondsParts[1]);
  
  return hours * 3600000 + minutes * 60000 + seconds * 1000 + milliseconds;
}

async function fetchDictionary(word: string): Promise<PapagoResponse | null> {
  try {
    const response = await fetch(`https://papago.naver.com/apis/dictionary/search?source=en&target=ko&text=${encodeURIComponent(word)}&locale=ko`, {
      headers: {
        "accept": "application/json",
        "accept-language": "ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7",
        "authorization": "PPG ffbaf550-ce4b-4478-ae20-ee54a0e3cd60:0q77fVjSF1Qh3crEdIDMKQ==",
        "cache-control": "no-cache",
        "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        "pragma": "no-cache",
        "priority": "u=1, i",
        "sec-ch-ua": "\"Not_A Brand\";v=\"99\", \"Chromium\";v=\"142\"",
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": "\"macOS\"",
        "sec-fetch-dest": "empty",
        "sec-fetch-mode": "cors",
        "sec-fetch-site": "same-origin",
        'timestamp': Date.now().toString(),
        "x-apigw-partnerid": "papago",
        "x-ppg-ctype": "WEB_PC",
        "cookie": "NNB=ZFCDE4DECVCWQ; _ga_8P4PY65YZ2=GS2.1.s1749365250$o1$g0$t1749365250$j60$l0$h0; ba.uuid=4c6155ad-568d-4b70-bfac-a51e7da4bbcf; ASID=3b0589f40000019827bcdb750000001d; bnb_tooltip_shown_finance_v1=true; _ga=GA1.2.1705893687.1749365250; ab.storage.userId.7d7bb94a-f465-48e5-bec1-35db97daf128=g%3AZ2JG%7Ce%3Aundefined%7Cc%3A1761905082349%7Cl%3A1761905082350; ab.storage.deviceId.7d7bb94a-f465-48e5-bec1-35db97daf128=g%3A63dd0bf6-7986-8282-897c-5526a566b2ab%7Ce%3Aundefined%7Cc%3A1761905082350%7Cl%3A1761905082350; ab.storage.sessionId.7d7bb94a-f465-48e5-bec1-35db97daf128=g%3Ad2c680c5-2d3f-9d2b-c3fb-42785b70ed6b%7Ce%3A1761907197910%7Cc%3A1761905082349%7Cl%3A1761905397910; NV_WETR_LOCATION_RGN_M=\"MDYxNDAxMDE=\"; NV_WETR_LAST_ACCESS_RGN_M=\"MDYxNDAxMDE=\"; NAC=OLdABsQZqteGA; page_uid=jfNfawpzLiwssDoLlS8ssssss24-215133; NACT=1; nid_inf=1426211877; papago_skin_locale=ko; SRT30=1764406270; SRT5=1764406270; BUC=RzB0uuyqkGsQmKdpHTlI80xtxirvT3VORUdOrARznUE=",
        "Referer": "https://papago.naver.com/"
      },
      method: "GET"
    });

    console.log(`ğŸ“¡ API Response for "${word}": Status ${response.status}`);

    if (!response.ok) {
      console.log(`âš ï¸ API returned status ${response.status} for word: ${word}`);
      return null;
    }

    const data = await response.json() as PapagoResponse;
    console.log(`ğŸ“¦ Received data for "${word}":`, JSON.stringify(data).substring(0, 200) + '...');
    return data;
  } catch (error: any) {
    console.log(`âŒ Fetch error for word "${word}": ${error.message}`);
    return null;
  }
}

async function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function translateWithPapago(text: string): Promise<string> {
  try {
    const response = await fetch('https://papago.naver.com/apis/nsmt/translate', {
      method: 'POST',
      headers: {
        "accept": "application/json",
        "accept-language": "ko",
        "authorization": "PPG ffbaf550-ce4b-4478-ae20-ee54a0e3cd60:3nITCzO9GCSWr9L0e/ZJww==",
        "cache-control": "no-cache",
        "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        "device-type": "pc",
        "pragma": "no-cache",
        "priority": "u=1, i",
        "sec-ch-ua": "\"Not_A Brand\";v=\"99\", \"Chromium\";v=\"142\"",
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": "\"macOS\"",
        "sec-fetch-dest": "empty",
        "sec-fetch-mode": "cors",
        "sec-fetch-site": "same-origin",
        'timestamp': Date.now().toString(),
        "x-apigw-partnerid": "papago",
        "x-ppg-ctype": "WEB_PC",
        "cookie": "NNB=ZFCDE4DECVCWQ; _ga_8P4PY65YZ2=GS2.1.s1749365250$o1$g0$t1749365250$j60$l0$h0; ba.uuid=4c6155ad-568d-4b70-bfac-a51e7da4bbcf; ASID=3b0589f40000019827bcdb750000001d; bnb_tooltip_shown_finance_v1=true; _ga=GA1.2.1705893687.1749365250; ab.storage.userId.7d7bb94a-f465-48e5-bec1-35db97daf128=g%3AZ2JG%7Ce%3Aundefined%7Cc%3A1761905082349%7Cl%3A1761905082350; ab.storage.deviceId.7d7bb94a-f465-48e5-bec1-35db97daf128=g%3A63dd0bf6-7986-8282-897c-5526a566b2ab%7Ce%3Aundefined%7Cc%3A1761905082350%7Cl%3A1761905082350; ab.storage.sessionId.7d7bb94a-f465-48e5-bec1-35db97daf128=g%3Ad2c680c5-2d3f-9d2b-c3fb-42785b70ed6b%7Ce%3A1761907197910%7Cc%3A1761905082349%7Cl%3A1761905397910; NV_WETR_LOCATION_RGN_M=\"MDYxNDAxMDE=\"; NV_WETR_LAST_ACCESS_RGN_M=\"MDYxNDAxMDE=\"; NAC=OLdABsQZqteGA; page_uid=jfNfawpzLiwssDoLlS8ssssss24-215133; NACT=1; nid_inf=1426211877; papago_skin_locale=ko; SRT30=1764406270; SRT5=1764406270; BUC=uD_D-1wRQ_qrJ2TBY9cJtxbW9ArFsXht-Uga8wXo35o=",
        "Referer": "https://papago.naver.com/"
      },
      body: new URLSearchParams({
        deviceId: 'ffbaf550-ce4b-4478-ae20-ee54a0e3cd60',
        locale: 'ko',
        dict: 'false',
        dictDisplay: '30',
        honorific: 'false',
        instant: 'true',
        paging: 'false',
        source: 'en',
        target: 'ko',
        text: text,
        usageAgreed: 'true'
      })
    });

    if (!response.ok) {
      return '';
    }

    const data = await response.json() as { translatedText: string };
    return data.translatedText || '';
  } catch (error) {
    console.log(`âš ï¸ Papago translation failed for: ${text.substring(0, 50)}...`);
    return '';
  }
}

async function processDictionary(subtitles: SubtitleEntry[]): Promise<void> {
  try {
    console.log('\nğŸ“š Processing dictionary for words...');
    
    // Create dictionary directory if it doesn't exist
    if (!fs.existsSync(DICTIONARY_DIR)) {
      fs.mkdirSync(DICTIONARY_DIR, { recursive: true });
    }
    
    // Extract all unique words
    const allWords = new Set<string>();
    
    subtitles.forEach(subtitle => {
      const words = subtitle.e
        .split(/\s+/)
        .map(word => word.replace(/[,.":!?;()]/g, '').toLowerCase())
        .filter(word => word.length > 0 && /^[a-zA-Z']+$/.test(word));
      
      words.forEach(word => allWords.add(word));
    });
    
    console.log(`ğŸ“– Found ${allWords.size} unique words`);
    
    let processedCount = 0;
    let skippedCount = 0;
    let successCount = 0;
    let failedCount = 0;
    const totalWords = allWords.size;
    
    for (const word of allWords) {
      const dictionaryPath = path.join(DICTIONARY_DIR, `${word}.json`);
      
      // Skip if dictionary file already exists
      if (fs.existsSync(dictionaryPath)) {
        skippedCount++;
        if ((processedCount + skippedCount) % 50 === 0) {
          console.log(`[${processedCount + skippedCount}/${totalWords}] Progress: ${skippedCount} skipped, ${successCount} fetched, ${failedCount} failed`);
        }
        continue;
      }
      
      console.log(`[${processedCount + skippedCount + 1}/${totalWords}] Fetching: ${word}`);
      
      const dictionaryData = await fetchDictionary(word);
      
      if (dictionaryData) {
        try {
          fs.writeFileSync(dictionaryPath, JSON.stringify(dictionaryData, null, 2), 'utf-8');
          successCount++;
          console.log(`âœ… Saved: ${word}.json (${dictionaryPath})`);
          
          // íŒŒì¼ì´ ì‹¤ì œë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
          if (fs.existsSync(dictionaryPath)) {
            const stats = fs.statSync(dictionaryPath);
            console.log(`   ğŸ“„ File size: ${stats.size} bytes`);
          } else {
            console.log(`   âš ï¸ Warning: File was not created!`);
          }
        } catch (writeError: any) {
          console.log(`âŒ Error writing file for "${word}": ${writeError.message}`);
          failedCount++;
        }
      } else {
        failedCount++;
        console.log(`âŒ Failed to fetch: ${word}`);
        
        // Rate limiting ê°ì§€ - ì—°ì† ì‹¤íŒ¨ ì‹œ ë” ê¸´ ëŒ€ê¸°
        if (failedCount >= 3) {
          console.log(`âš ï¸ Multiple failures detected. Waiting 5 seconds...`);
          await delay(5000);
          failedCount = 0; // ì¹´ìš´í„° ë¦¬ì…‹
        }
      }
      
      processedCount++;
      
      // Add delay to avoid rate limiting (1ì´ˆë¡œ ì¦ê°€)
      await delay(1000);
    }
    
    console.log(`\nâœ… Dictionary processing complete!`);
    console.log(`   - Total words: ${totalWords}`);
    console.log(`   - Already existed: ${skippedCount}`);
    console.log(`   - Newly fetched: ${successCount}`);
    console.log(`   - Failed: ${failedCount}`);
    
  } catch (error: any) {
    console.error('âŒ Error processing dictionary:', error.message);
  }
}

function parseVttContent(vttContent: string): Array<{ text: string; startTime: number; endTime: number }> {
  const lines = vttContent.split('\n');
  const cues: Array<{ text: string; startTime: number; endTime: number }> = [];
  
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    
    if (line.includes('-->')) {
      try {
        const [startStr, endStr] = line.split('-->').map(s => s.trim());
        const startTime = parseVttTime(startStr);
        const endTime = parseVttTime(endStr);
        
        i++;
        let text = '';
        while (i < lines.length && lines[i].trim() !== '') {
          text += lines[i].trim() + ' ';
          i++;
        }
        
        if (text.trim()) {
          cues.push({
            text: text.trim(),
            startTime,
            endTime
          });
        }
      } catch (error) {
        console.log(`âš ï¸ Error parsing VTT line: ${line}`);
      }
    }
    i++;
  }
  
  return cues;
}

async function copyVttFilesAndUpdateItems(videoTitle: string, subtitles: SubtitleData[]): Promise<void> {
  try {
    // VTT ë””ë ‰í† ë¦¬ ìƒì„±
    if (!fs.existsSync(VTT_DIR)) {
      fs.mkdirSync(VTT_DIR, { recursive: true });
    }
    
    // Auto-translation ë””ë ‰í† ë¦¬ ìƒì„±
    if (!fs.existsSync(AUTO_TRANSLATION_DIR)) {
      fs.mkdirSync(AUTO_TRANSLATION_DIR, { recursive: true });
    }

    // en-US ë˜ëŠ” en íŒŒì¼ ì°¾ê¸°
    const enSubtitle = subtitles.find(s => s.language === 'en-US') || subtitles.find(s => s.language === 'en');
    const koSubtitle = subtitles.find(s => s.language === 'ko');
    
    if (!enSubtitle) {
      console.log('âŒ No English subtitle found');
      return;
    }
    
    // íŒŒì¼ëª… ì •ë¦¬
    const cleanTitle = videoTitle.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
    
    // ì˜ì–´ VTT íŒŒì¼ ì €ì¥ (ì›ë³¸ ê·¸ëŒ€ë¡œ)
    const enSourcePath = path.join(OUTPUT_DIR, `${cleanTitle}.${enSubtitle.language}${enSubtitle.isAutoGenerated ? '.auto' : ''}.vtt`);
    const enDestPath = path.join(VTT_DIR, `${cleanTitle}.en.vtt`);
    
    if (fs.existsSync(enSourcePath)) {
      fs.copyFileSync(enSourcePath, enDestPath);
      console.log(`âœ… Copied English VTT: ${enDestPath}`);
    }
    
    // ì˜ì–´ ì›ë³¸ JSON ì €ì¥ (auto-translation ë””ë ‰í† ë¦¬)
    if (enSubtitle.originalJson) {
      const enJsonPath = path.join(AUTO_TRANSLATION_DIR, `${cleanTitle}.en.json`);
      fs.writeFileSync(enJsonPath, JSON.stringify(enSubtitle.originalJson, null, 2), 'utf-8');
      console.log(`âœ… Saved English original JSON: ${enJsonPath}`);
    }

    // í•œêµ­ì–´ VTT íŒŒì¼ ì €ì¥ (ì›ë³¸ ê·¸ëŒ€ë¡œ)
    if (koSubtitle) {
      const koSourcePath = path.join(OUTPUT_DIR, `${cleanTitle}.${koSubtitle.language}${koSubtitle.isAutoGenerated ? '.auto' : ''}.vtt`);
      const koDestPath = path.join(VTT_DIR, `${cleanTitle}.ko.vtt`);
      
      if (fs.existsSync(koSourcePath)) {
        fs.copyFileSync(koSourcePath, koDestPath);
        console.log(`âœ… Copied Korean VTT: ${koDestPath}`);
      }

      // í•œêµ­ì–´ ì›ë³¸ JSON ì €ì¥ (auto-translation ë””ë ‰í† ë¦¬)
      if (koSubtitle.originalJson) {
        const koJsonPath = path.join(AUTO_TRANSLATION_DIR, `${cleanTitle}.ko.json`);
        fs.writeFileSync(koJsonPath, JSON.stringify(koSubtitle.originalJson, null, 2), 'utf-8');
        console.log(`âœ… Saved Korean original JSON: ${koJsonPath}`);
      }
    }
    
    // items.json ì—…ë°ì´íŠ¸
    await updateItemsJson(videoTitle);
    
    // ë‹¨ì–´ ì‚¬ì „ ìƒì„± (ì˜ì–´ VTTì—ì„œ ë‹¨ì–´ ì¶”ì¶œ)
    const enCues = parseVttContent(enSubtitle.content);
    const allWords = new Set<string>();
    enCues.forEach(cue => {
      const words = cue.text.split(/\s+/)
        .map(word => word.replace(/[,.":!?;()]/g, '').toLowerCase())
        .filter(word => word.length > 0 && /^[a-zA-Z']+$/.test(word));
      words.forEach(word => allWords.add(word));
    });
    
    const subtitleEntries = Array.from(allWords).map(word => ({ e: word, k: '', t: '0s' }));
    await processDictionary(subtitleEntries as any);
    
    console.log('\nğŸ‰ Complete! VTT files and original JSONs saved, items updated!');
    
  } catch (error: any) {
    console.error('âŒ Error in copyVttFilesAndUpdateItems:', error.message);
  }
}

// ê¸°ì¡´ convertVttToJsonAndUpdate í•¨ìˆ˜ëŠ” ì œê±°í•˜ê³  ìƒˆë¡œìš´ í•¨ìˆ˜ë¡œ ëŒ€ì²´
async function convertVttToJsonAndUpdate_OLD(videoTitle: string, subtitles: SubtitleData[]): Promise<void> {
  try {
    console.log(`\nğŸ” Looking for subtitles in ${subtitles.length} captured items...`);
    subtitles.forEach(s => console.log(`  - ${s.language} (${s.content.length} chars)`));
    
    // ì˜ì–´ì™€ í•œêµ­ì–´ ìë§‰ ì°¾ê¸°
    // en-US ìš°ì„ , ì—†ìœ¼ë©´ en ì‚¬ìš©
    const enSubtitle = subtitles.find(s => s.language === 'en-US') || subtitles.find(s => s.language === 'en');
    const koSubtitle = subtitles.find(s => s.language === 'ko');
    
    if (!enSubtitle) {
      console.log('âŒ Missing English subtitle (tried en-US and en)');
      return;
    }
    
    console.log(`âœ… Using English subtitle: ${enSubtitle.language}`);
    
    console.log('ğŸ“ Parsing VTT files...');
    const enCues = parseVttContent(enSubtitle.content);
    console.log(`âœ… Parsed ${enCues.length} English cues`);
    
    if (enCues.length === 0) {
      console.log('âŒ No cues found in English VTT file');
      return;
    }
    
    // Papago ë²ˆì—­ ì‚¬ìš© ë˜ëŠ” í•œêµ­ì–´ ìë§‰ì´ ì—†ëŠ” ê²½ìš°
    if (TRANSLATION_METHOD === 'papago' || !koSubtitle) {
      if (TRANSLATION_METHOD === 'papago') {
        console.log('ğŸŒ Using Papago translation for Korean subtitles...');
      } else {
        console.log('âš ï¸  Korean subtitle not found - will use Papago translation');
      }
      
      // ì˜ì–´ ìë§‰ì„ Papagoë¡œ ë²ˆì—­
      const matchedSubtitles: SubtitleEntry[] = [];
      let translatedCount = 0;
      
      for (let i = 0; i < enCues.length; i++) {
        const enCue = enCues[i];
        const timeInSeconds = Math.floor(enCue.startTime / 1000);
        
        console.log(`[${i + 1}/${enCues.length}] Translating: ${enCue.text.substring(0, 50)}...`);
        
        const koText = await translateWithPapago(enCue.text);
        if (koText) {
          translatedCount++;
        }
        
        matchedSubtitles.push({
          t: `${timeInSeconds}s`,
          e: enCue.text,
          k: koText
        });
        
        // Rate limiting: 500ms delay between requests
        if (i < enCues.length - 1) {
          await delay(500);
        }
      }
      
      console.log(`âœ… Translated ${translatedCount} out of ${enCues.length} subtitles`);
      
      // JSON íŒŒì¼ ì €ì¥
      if (!fs.existsSync(SCRIPTS_DIR)) {
        fs.mkdirSync(SCRIPTS_DIR, { recursive: true });
      }
      
      const jsonFilePath = path.join(SCRIPTS_DIR, `${videoTitle}.json`);
      fs.writeFileSync(jsonFilePath, JSON.stringify(matchedSubtitles, null, 2), 'utf8');
      console.log(`âœ… Saved JSON: ${jsonFilePath}`);
      
      // items.json ì—…ë°ì´íŠ¸
      await updateItemsJson(videoTitle);
      
      // ë‹¨ì–´ ì‚¬ì „ ìƒì„±
      await processDictionary(matchedSubtitles);
      
      console.log('\nğŸ‰ Complete! (Translated with Papago)');
      return;
    }
    
    console.log('âœ… Found both English and Korean subtitles');
    console.log('ğŸ“ Parsing Korean VTT file...');
    
    const koCues = parseVttContent(koSubtitle.content);
    console.log(`âœ… Parsed ${koCues.length} Korean cues`);
    
    if (koCues.length === 0) {
      console.log('âŒ No cues found in Korean VTT file');
      return;
    }
    
    // ì‹œê°„ ê¸°ë°˜ìœ¼ë¡œ ìë§‰ ë§¤ì¹­ (ì˜ì–´ ì‹œê°„ ë²”ìœ„ ë‚´ì˜ ëª¨ë“  í•œêµ­ì–´ ìë§‰ í•©ì¹˜ê¸°)
    const matchedSubtitles: SubtitleEntry[] = [];
    
    for (const enCue of enCues) {
      // ì˜ì–´ ìë§‰ì˜ ì‹œê°„ ë²”ìœ„ ë‚´ì— ìˆëŠ” ëª¨ë“  í•œêµ­ì–´ ìë§‰ ì°¾ê¸°
      const overlappingKoCues = koCues.filter(koCue => {
        const overlap = Math.min(enCue.endTime, koCue.endTime) - Math.max(enCue.startTime, koCue.startTime);
        return overlap > 0;
      });
      
      // ì‹œì‘ ì‹œê°„ ìˆœìœ¼ë¡œ ì •ë ¬
      overlappingKoCues.sort((a, b) => a.startTime - b.startTime);
      
      // ëª¨ë“  í•œêµ­ì–´ ìë§‰ì„ / ë¡œ êµ¬ë¶„í•˜ì—¬ ì—°ê²°
      const koText = overlappingKoCues.map(koCue => koCue.text).join(' / ');
      
      // ì‹œê°„ì„ ì´ˆ ë‹¨ìœ„ ë¬¸ìì—´ë¡œ ë³€í™˜ (ì˜ˆ: "0s", "6s")
      const timeInSeconds = Math.floor(enCue.startTime / 1000);
      
      matchedSubtitles.push({
        t: `${timeInSeconds}s`,
        e: enCue.text,
        k: koText
      });
    }
    
    console.log(`âœ… Matched ${matchedSubtitles.filter(s => s.k).length} out of ${matchedSubtitles.length} English subtitles with Korean`);
    
    console.log(`âœ… Matched ${matchedSubtitles.length} subtitle pairs`);
    
    // JSON íŒŒì¼ ì €ì¥
    if (!fs.existsSync(SCRIPTS_DIR)) {
      fs.mkdirSync(SCRIPTS_DIR, { recursive: true });
    }
    
    const jsonFilePath = path.join(SCRIPTS_DIR, `${videoTitle}.json`);
    fs.writeFileSync(jsonFilePath, JSON.stringify(matchedSubtitles, null, 2), 'utf8');
    console.log(`âœ… Saved JSON: ${jsonFilePath}`);
    
    // items.json ì—…ë°ì´íŠ¸
    let items: VideoItem[] = [];
    if (fs.existsSync(ITEMS_JSON_PATH)) {
      const itemsContent = fs.readFileSync(ITEMS_JSON_PATH, 'utf8');
      items = JSON.parse(itemsContent);
      console.log(`ğŸ“– Read existing items.json with ${items.length} items`);
    } else {
      console.log(`âš ï¸ items.json not found at: ${ITEMS_JSON_PATH}`);
    }
    
    // ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸ (linkë¡œ ë¹„êµ)
    const youtubeLink = `https://www.youtube.com/watch?v=${YOUTUBE_VIDEO_ID}`;
    const existingIndex = items.findIndex(item => item.link === youtubeLink);
    
    const newItem: VideoItem = {
      name: videoTitle,
      type: 'youtube',
      img: `https://img.youtube.com/vi/${YOUTUBE_VIDEO_ID}/0.jpg`,
      link: youtubeLink
    };
    
    if (existingIndex >= 0) {
      items[existingIndex] = newItem;
      console.log(`âœ… Updated existing item in items.json`);
    } else {
      items.push(newItem);
      console.log(`âœ… Added new item to items.json`);
    }
    
    fs.writeFileSync(ITEMS_JSON_PATH, JSON.stringify(items, null, 2), 'utf8');
    console.log(`âœ… Saved items.json: ${ITEMS_JSON_PATH}`);
    
    // ë‹¨ì–´ ì‚¬ì „ ìƒì„±
    await processDictionary(matchedSubtitles);
    
    console.log('\nğŸ‰ Complete! All files generated and updated successfully!');
  } catch (error: any) {
    console.error('âŒ Error in convertVttToJsonAndUpdate:', error.message);
  }
}

async function updateItemsJson(videoTitle: string): Promise<void> {
  try {
    // items.json ì—…ë°ì´íŠ¸
    let items: VideoItem[] = [];
    if (fs.existsSync(ITEMS_JSON_PATH)) {
      const itemsContent = fs.readFileSync(ITEMS_JSON_PATH, 'utf8');
      items = JSON.parse(itemsContent);
      console.log(`ğŸ“– Read existing items.json with ${items.length} items`);
    } else {
      console.log(`âš ï¸ items.json not found at: ${ITEMS_JSON_PATH}`);
    }

    // ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸ (linkë¡œ ë¹„êµ)
    const youtubeLink = `https://www.youtube.com/watch?v=${YOUTUBE_VIDEO_ID}`;
    const existingIndex = items.findIndex(item => item.link === youtubeLink);

    // VTT íŒŒì¼ëª…ê³¼ ë™ì¼í•˜ê²Œ íŠ¹ìˆ˜ë¬¸ì ì œê±°
    const cleanTitle = videoTitle.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);

    const newItem: VideoItem = {
      name: cleanTitle,  // íŒŒì¼ëª…ê³¼ ë™ì¼í•˜ê²Œ ì •ë¦¬ëœ ì œëª© ì‚¬ìš©
      type: 'youtube',
      img: `https://img.youtube.com/vi/${YOUTUBE_VIDEO_ID}/0.jpg`,
      link: youtubeLink
    };

    if (existingIndex >= 0) {
      items[existingIndex] = newItem;
      console.log(`âœ… Updated existing item in items.json`);
    } else {
      items.push(newItem);
      console.log(`âœ… Added new item to items.json`);
    }

    fs.writeFileSync(ITEMS_JSON_PATH, JSON.stringify(items, null, 2), 'utf8');
    console.log(`âœ… Saved items.json: ${ITEMS_JSON_PATH}`);

  } catch (error: any) {
    console.error('âŒ Error in convertVttToJsonAndUpdate:', error.message);
  }
}

async function saveSubtitle(subtitleData: SubtitleData, videoTitle: string): Promise<void> {
  try {
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    const cleanTitle = videoTitle.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
    const autoSuffix = subtitleData.isAutoGenerated ? '.auto' : '';
    const filename = `${cleanTitle}.${subtitleData.language}${autoSuffix}.vtt`;
    const filepath = path.join(OUTPUT_DIR, filename);

    fs.writeFileSync(filepath, subtitleData.content, 'utf8');
    
    console.log(`âœ… Saved: ${filename}`);
    console.log(`ğŸ“ Path: ${filepath}`);
    
  } catch (error: any) {
    console.error(`âŒ Error saving ${subtitleData.language} subtitle:`, error.message);
  }
}

async function downloadYouTubeSubtitles() {
  console.log(`ğŸ¥ YouTube Video ID: ${YOUTUBE_VIDEO_ID}`);
  console.log(`ğŸ”— YouTube URL: ${YOUTUBE_URL}`);
  console.log(`ğŸ“ Output Directory: ${OUTPUT_DIR}`);
  console.log('');

  console.log('ğŸš€ Launching browser...');
  const browser = await chromium.launch({ 
    headless: false,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-blink-features=AutomationControlled',
      '--disable-dev-shm-usage',
      '--disable-web-security'
    ],
    slowMo: 300
  });
  
  const context = await browser.newContext({
    userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    viewport: { width: 1920, height: 1080 },
    locale: 'ko-KR',
    timezoneId: 'Asia/Seoul',
    permissions: ['geolocation']
  });
  
  await context.addInitScript(() => {
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined
    });
    
    (window as any).chrome = {
      runtime: {}
    };
    
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters: any) => (
      parameters.name === 'notifications' ?
        Promise.resolve({ state: 'denied' } as PermissionStatus) :
        originalQuery(parameters)
    );
  });
  
  const page = await context.newPage();
  const capturedSubtitles: SubtitleData[] = [];
  const client = await context.newCDPSession(page);
  await client.send('Network.enable');
  
  // ìë§‰ ìº¡ì²˜ í™œì„±í™” í”Œë˜ê·¸
  let captureEnabled = false;

  // ìš”ì²­ IDë¥¼ ì¶”ì í•˜ê¸° ìœ„í•œ Map
  const pendingRequests = new Map<string, { url: string; language: string; isAutoGenerated: boolean }>();

  client.on('Network.responseReceived', (params: any) => {
    const url = params.response.url;
    
    if (url.includes('timedtext') && !url.includes('.js')) {
      // ìº¡ì²˜ê°€ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë¬´ì‹œ
      if (!captureEnabled) {
        console.log(`â­ï¸ Skipping timedtext (capture not enabled yet): ${url.substring(0, 100)}...`);
        return;
      }

      console.log(`ğŸ“¡ Network response received: ${url.substring(0, 150)}...`);
      console.log(`ğŸ“Š RequestId: ${params.requestId}, Status: ${params.response.status}, MIME: ${params.response.mimeType}`);
      
      const langMatch = url.match(/[&?]lang=([^&]+)/);
      const tlangMatch = url.match(/[&?]tlang=([^&]+)/);
      
      let language = tlangMatch?.[1] || langMatch?.[1] || 'unknown';
      language = decodeURIComponent(language);
      
      const isAutoGenerated = url.includes('kind=asr');
      
      // ìš”ì²­ ì •ë³´ ì €ì¥
      pendingRequests.set(params.requestId, { url, language, isAutoGenerated });
      console.log(`ğŸ“ Stored request info for ${language} (RequestId: ${params.requestId})`);
    }
  });

  client.on('Network.loadingFinished', async (params: any) => {
    const requestInfo = pendingRequests.get(params.requestId);
    
    if (!requestInfo) {
      return;
    }

    console.log(`âœ… Loading finished for ${requestInfo.language} (RequestId: ${params.requestId})`);
    
    try {
      console.log(`ğŸ”„ Attempting to get response body for ${requestInfo.language}...`);
      
      const responseBody = await client.send('Network.getResponseBody', {
        requestId: params.requestId
      });
      
      let content = '';
      if (responseBody.base64Encoded) {
        content = Buffer.from(responseBody.body, 'base64').toString('utf-8');
        console.log(`ğŸ“¦ Decoded base64 content: ${content.length} bytes`);
      } else {
        content = responseBody.body;
        console.log(`ğŸ“¦ Got text content: ${content.length} bytes`);
      }
      
      let processedContent = content;
      let originalJson: any = null;

      if (requestInfo.url.includes('fmt=json3') && content.trim().startsWith('{')) {
        try {
          const jsonData = JSON.parse(content);
          originalJson = jsonData;
          processedContent = convertJson3ToVtt(jsonData);
          console.log(`ğŸ”„ Converted JSON3 to VTT for ${requestInfo.language}`);
        } catch (parseError) {
          console.log(`âš ï¸ Failed to parse JSON3: ${parseError}`);
        }
      }
      
      if (processedContent && processedContent.trim().length > 10) {
        capturedSubtitles.push({
          language: requestInfo.language,
          content: processedContent,
          isAutoGenerated: requestInfo.isAutoGenerated,
          url: requestInfo.url,
          originalJson
        });
        console.log(`ğŸ’¾ Stored subtitle data for ${requestInfo.language} (${processedContent.length} chars)`);
      } else {
        console.log(`âš ï¸ Content too short for ${requestInfo.language}: ${processedContent.length} chars`);
      }
      
      // ì²˜ë¦¬ ì™„ë£Œëœ ìš”ì²­ ì œê±°
      pendingRequests.delete(params.requestId);
      
    } catch (error: any) {
      console.log(`âŒ Error getting response body for ${requestInfo.language}: ${error.message}`);
      console.log(`   RequestId: ${params.requestId}`);
      console.log(`   URL: ${requestInfo.url.substring(0, 150)}...`);
      pendingRequests.delete(params.requestId);
    }
  });

  try {
    console.log('ğŸŒ Navigating to YouTube page...');
    await page.goto(YOUTUBE_URL, { waitUntil: 'networkidle' });
    
    console.log('â³ Waiting for page to fully load...');
    await page.waitForTimeout(3000);
    
    // ê´‘ê³  ìŠ¤í‚µ ì²˜ë¦¬
    console.log('ğŸ“º Checking for ads...');
    try {
      // ê´‘ê³ ê°€ ìˆëŠ”ì§€ í™•ì¸ (ìµœëŒ€ 5ì´ˆ ëŒ€ê¸°)
      const adExists = await page.locator('.video-ads').isVisible({ timeout: 5000 }).catch(() => false);
      
      if (adExists) {
        console.log('â­ï¸  Ad detected, waiting for skip button...');
        
        // ìŠ¤í‚µ ë²„íŠ¼ì´ ë‚˜íƒ€ë‚  ë•Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 10ì´ˆ)
        const skipButton = page.locator('button.ytp-ad-skip-button, button.ytp-skip-ad-button, .ytp-ad-skip-button-modern');
        await skipButton.waitFor({ state: 'visible', timeout: 10000 }).catch(() => {
          console.log('âš ï¸ Skip button not found, continuing anyway...');
        });
        
        // ìŠ¤í‚µ ë²„íŠ¼ í´ë¦­
        if (await skipButton.isVisible().catch(() => false)) {
          await skipButton.click();
          console.log('âœ… Ad skipped!');
          await page.waitForTimeout(1000);
        }
      } else {
        console.log('âœ… No ads detected');
      }
    } catch (error) {
      console.log('âš ï¸ Ad handling error (continuing anyway):', error);
    }
    
    const videoTitle = await page.evaluate(() => {
      const titleSelectors = [
        'h1.ytd-video-primary-info-renderer',
        'meta[property="og:title"]',
        'title'
      ];
      
      for (const selector of titleSelectors) {
        const element = document.querySelector(selector);
        if (element) {
          if (element.tagName === 'META') {
            return (element as any).content;
          } else if (element.tagName === 'TITLE') {
            return element.textContent?.replace(' - YouTube', '') || '';
          } else {
            return element.textContent || '';
          }
        }
      }
      
      return `YouTube_Video_${(window as any).location.search.match(/v=([^&]+)/)?.[1] || 'unknown'}`;
    });
    
    console.log(`ğŸ¬ Video Title: ${videoTitle}`);
    
    // ìë§‰ ìº¡ì²˜ í™œì„±í™” (ì´ì œë¶€í„° timedtext ìš”ì²­ì„ ìº¡ì²˜í•¨)
    console.log('âœ… Enabling subtitle capture...');
    captureEnabled = true;

    // 0. ìë§‰ ì´ˆê¸°í™” - "ì‚¬ìš© ì•ˆí•¨"ìœ¼ë¡œ ì„¤ì •
    console.log('ğŸ”§ Opening settings to disable subtitles first...');
    await page.click('button.ytp-settings-button', { timeout: 5000 });
    await page.waitForTimeout(1000);
    
    console.log('ğŸ“ Opening subtitles menu...');
    await page.locator('text=ìë§‰').click({ timeout: 5000 });
    await page.waitForTimeout(1500);
    
    console.log('âŒ Setting subtitles to "ì‚¬ìš© ì•ˆí•¨"...');
    try {
      await page.locator('[role="menuitemradio"]').filter({ hasText: 'ì‚¬ìš© ì•ˆí•¨' }).first().click({ timeout: 3000 });
      console.log('âœ… Subtitles disabled');
    } catch {
      try {
        await page.locator('[role="menuitemradio"]').filter({ hasText: 'Off' }).first().click({ timeout: 3000 });
        console.log('âœ… Subtitles turned off');
      } catch {
        console.log('âš ï¸ Could not find disable option, continuing anyway...');
      }
    }
    await page.waitForTimeout(1000);
    await page.keyboard.press('Escape');
    await page.waitForTimeout(500);

    // 1. ì˜ì–´ ìë§‰ ê°€ì ¸ì˜¤ê¸°
    console.log('ğŸ”§ Clicking settings button for English subtitles...');
    await page.click('button.ytp-settings-button', { timeout: 5000 });
    await page.waitForTimeout(1000);
    
    console.log('ğŸ“ Clicking subtitles menu...');
    await page.locator('text=ìë§‰').click({ timeout: 5000 });
    await page.waitForTimeout(1500);
    
    console.log('ğŸ‡ºğŸ‡¸ Selecting English subtitles...');
    // ì˜ì–´ ìë§‰ ì„ íƒ ì‹œë„ (ì›ë³¸ ìš°ì„ , ìë™ ìƒì„±ì€ ë‚˜ì¤‘ì—)
    let englishSelected = false;
    
    // 1ìˆœìœ„: ì›ë³¸ ì˜ì–´ ìë§‰ë“¤
    const originalEnglishOptions = [
      /^ì˜ì–´$/,
      /^ì˜ì–´\(ë¯¸êµ­\)$/,
      /^ì˜ì–´\(ë¯¸êµ­\) - Captions$/,
      /^English$/,
      /^English \(United States\)$/,
      /^English \(US\)$/
    ];
    
    for (const pattern of originalEnglishOptions) {
      try {
        await page.locator('[role="menuitemradio"]').filter({ hasText: pattern }).first().click({ timeout: 2000 });
        console.log(`âœ… Selected: ${pattern.source} (original)`);
        englishSelected = true;
        break;
      } catch {
        continue;
      }
    }
    
    // 2ìˆœìœ„: ìë™ ìƒì„± ì˜ì–´ ìë§‰ë“¤
    if (!englishSelected) {
      const autoGeneratedOptions = [
        'ì˜ì–´ (ìë™ ìƒì„±ë¨)',
        'ì˜ì–´(ë¯¸êµ­) (ìë™ ìƒì„±ë¨)',
        'English (auto-generated)',
        'English (United States) (auto-generated)'
      ];
      
      for (const option of autoGeneratedOptions) {
        try {
          await page.locator('[role="menuitemradio"]').filter({ hasText: option }).first().click({ timeout: 2000 });
          console.log(`âœ… Selected: ${option}`);
          englishSelected = true;
          break;
        } catch {
          continue;
        }
      }
    }
    
    // 3ìˆœìœ„: ìë™ ë²ˆì—­ìœ¼ë¡œ ì˜ì–´ ì„ íƒ
    if (!englishSelected) {
      console.log('âš ï¸ No direct English subtitle found, trying auto-translate...');
      const autoTranslateExists = await page.locator('text=ìë™ ë²ˆì—­').isVisible({ timeout: 2000 }).catch(() => false);
      
      if (autoTranslateExists) {
        console.log('âœ… Found auto-translate menu');
        await page.locator('text=ìë™ ë²ˆì—­').click({ timeout: 5000 });
        await page.waitForTimeout(1500);
        
        console.log('ğŸ‡ºğŸ‡¸ Selecting English from auto-translate...');
        try {
          await page.locator('[role="menuitemradio"]:has-text("ì˜ì–´")').first().click({ timeout: 5000 });
          console.log('âœ… Selected: ì˜ì–´ (auto-translate)');
          englishSelected = true;
        } catch {
          await page.locator('[role="menuitemradio"]:has-text("English")').first().click({ timeout: 5000 });
          console.log('âœ… Selected: English (auto-translate)');
          englishSelected = true;
        }
      }
    }
    
    if (!englishSelected) {
      throw new Error('âŒ Could not find any English subtitle option');
    }
    
    console.log('ğŸ“¡ Waiting for English subtitle data...');
    await page.waitForTimeout(3000);
    
    // 2. í•œêµ­ì–´ ìë§‰ ê°€ì ¸ì˜¤ê¸° (ìë™ë²ˆì—­ â†’ í•œêµ­ì–´)
    console.log('ğŸ”™ Going back to subtitle menu...');
    await page.keyboard.press('Escape');
    await page.waitForTimeout(500);
    
    console.log('ğŸ”§ Reopening settings menu...');
    await page.click('button.ytp-settings-button', { timeout: 5000 });
    await page.waitForTimeout(1000);
    
    console.log('ğŸ“ Clicking subtitles menu...');
    await page.locator('text=ìë§‰').click({ timeout: 5000 });
    await page.waitForTimeout(1500);
    
    console.log('ğŸŒ Looking for Korean subtitle options...');
    
    // 1ìˆœìœ„: ì§ì ‘ í•œêµ­ì–´ ìë§‰ì´ ìˆëŠ”ì§€ í™•ì¸
    const koreanSubtitleExists = await page.locator('[role="menuitemradio"]').filter({ hasText: /^í•œêµ­ì–´$/ }).isVisible({ timeout: 2000 }).catch(() => false);
    
    if (koreanSubtitleExists) {
      console.log('âœ… Found direct Korean subtitle');
      await page.locator('[role="menuitemradio"]').filter({ hasText: /^í•œêµ­ì–´$/ }).first().click({ timeout: 3000 });
      console.log('âœ… Selected: í•œêµ­ì–´');
    } else {
      console.log('âš ï¸ Direct Korean subtitle not found, checking auto-translate...');
      
      // 2ìˆœìœ„: ìë™ ë²ˆì—­ ë©”ë‰´ í™•ì¸
      const autoTranslateExists = await page.locator('text=ìë™ ë²ˆì—­').isVisible({ timeout: 2000 }).catch(() => false);
      
      if (autoTranslateExists) {
        console.log('âœ… Found auto-translate menu');
        await page.locator('text=ìë™ ë²ˆì—­').click({ timeout: 5000 });
        await page.waitForTimeout(1500);
        
        console.log('ğŸ‡°ğŸ‡· Selecting Korean language from auto-translate...');
        await page.locator('[role="menuitemradio"]:has-text("í•œêµ­ì–´")').first().click({ timeout: 5000 });
        console.log('âœ… Selected: í•œêµ­ì–´ (auto-translate)');
      } else {
        console.log('âš ï¸ Auto-translate not found, looking for ì˜ì–´(ë¯¸êµ­)...');
        
        // 3ìˆœìœ„: ì˜ì–´(ë¯¸êµ­) ì°¾ì•„ì„œ í´ë¦­
        try {
          await page.locator('[role="menuitemradio"]').filter({ hasText: 'ì˜ì–´(ë¯¸êµ­)' }).first().click({ timeout: 3000 });
          console.log('âœ… Selected: ì˜ì–´(ë¯¸êµ­)');
        } catch {
          console.log('âš ï¸ ì˜ì–´(ë¯¸êµ­) not found, trying English (United States)...');
          await page.locator('[role="menuitemradio"]').filter({ hasText: 'English (United States)' }).first().click({ timeout: 3000 });
          console.log('âœ… Selected: English (United States)');
        }
      }
    }
    
    console.log('ğŸ“¡ Waiting for Korean subtitle data...');
    await page.waitForTimeout(5000);
    
    await page.keyboard.press('Escape');
    
    console.log('â³ Final wait for all network requests...');
    await page.waitForTimeout(3000);
    
    console.log(`\nğŸ“Š Captured ${capturedSubtitles.length} subtitle(s)`);
    
    if (capturedSubtitles.length > 0) {
      // 1. VTT íŒŒì¼ ì €ì¥
      for (const subtitle of capturedSubtitles) {
        console.log(`\nğŸ’¾ Processing ${subtitle.language} subtitle...`);
        await saveSubtitle(subtitle, videoTitle);
      }
      
      console.log('\nâœ… All VTT files saved successfully!');
      console.log(`ğŸ“‚ VTT files location: ${OUTPUT_DIR}`);
      
      // 2. VTT íŒŒì¼ ë³µì‚¬ ë° items.json ì—…ë°ì´íŠ¸
      console.log('\nğŸ“‹ Copying VTT files and updating items.json...');
      await copyVttFilesAndUpdateItems(videoTitle, capturedSubtitles);
      
    } else {
      console.log('âŒ No subtitles were captured');
    }

  } catch (error: any) {
    console.error('âŒ Error:', error.message);
  } finally {
    await browser.close();
  }
}

console.log('ğŸ¬ YouTube Subtitle Downloader (Network Interception)');
console.log('===================================================');
downloadYouTubeSubtitles();
